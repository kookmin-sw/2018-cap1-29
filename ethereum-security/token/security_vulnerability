3.1 Transaction-Ordering Dependence

블록체인은 거래set 포함하므로 블록 체인 상태는 각 epoch마다 여러 번 업데이트된다. 
사용자는 개별 호출이 실행될 때 계약 상태에 대해 확실하지 않은 정보를 가지고 있다. 
따라서 사용자가 호출할 수 있는 계약상태와 실제 상태가 다를 수 있다. 
블록 채굴자만이 업데이트 순서를 결정할 수 있으므로 계약의 최종 상태는 채굴자가 트랜잭션을 호출하는 순서에 따라 달라진다. 
우리는 그러한 계약을 거래 주문 종속계약이라고 부른다.
이 계약이 문제가 되는 이유는 명확하지 않지만 두 가지 있다. 
첫째, 동시에 호출할 경우 계약에 대한 올바른 호출도 사용자에게 예기치 않은 결과를 가져올 수 있다. 
둘째, 악의적인 사용자가 TOD 계약을 이용하여 더 많은 수익을 올리거나 사용자의 돈을 훔칠 수 있다. 
사용자는 먼저 이를 실행하면 예상과 다른 보상을 받을 수 있다. 
거래 주문에 따라 사용자의 구매 요청이 통과할지는 다를 수 있다. 
더 나쁜 상황은 구매자가 구매 요청을 할 때 예상된 가격보다 훨씬 높은 가격을 지불해야 할 수도 있다는 것이다. 
소유자는 채굴에 직접 참여하여 거래에 대한 높은 가스 가격을 설정함으로써 또는 채굴에 직접 참여함으로써 처음 실행되는 거래의 기회를 편향시킬 수 있다. 

3.2 Timestamp Dependence

계약의 다음 보안 문제는 일부 중요한 작업을 실행하기 위한 trigger조건으로 타임스탬프를 사용하는데 일반적으로 타임 스탬프는 채굴자의 로컬 시스템의 현재 시간으로 설정된다. 
채굴자는 약 900 초 동안 이 값을 변경할 수 있지만 그러나 여전히 다른 채굴자는 새로운 블록을 받아서 다른 유효성 검사를 확인한 후, 블록 타임 스탬프가 이전보다 크고 로컬 시스템의 타임 스탬프에서
900초 내에 있는지 여부를 검사한다. 
따라서, 악의적으로 타임 스탬프에 의존하는 계약의 결과를 조작하기 위해 다른 블록 타임 스탬프를 선택할 수 있다.
채굴자는 블록 타임 스탬프를 타임 스탬프 종속 조건의 값에 영향을 미치고 채굴자가 선호하는 특정 값으로 설정할 수 있 기 때문에 이는 타임 스탬프를 사용한 계약 조작의 취약성을 보여준다. 
그리고 불행하게도 타임 스탬프에 종속되는 다른 많은 계약이 있다. 

3.3 Mishandled Exceptions

호출된 계약에서 예외가 발생하면 수신된 계약이 종료되고 이전 상태로 되돌아가서 false를 반환한다. 
그러나 호출 방법에 따라 예외가 호출자에게 전달되거나 전달되지 않을 수도 있다. 
이 일관성 없는 예외 알림 정책은 예외가 제대로 처리되지 않는 경우를 많이 초래한다. 
계약을 호출하는 악의적인 사용자는 수신자의 의도와 관계없이 의도적으로 전송을 실패하게 하거나 호출 스택의 깊이 제한을 초과한다. 
EVM은 호출 스택의 깊이를 1024 프레임으로 제한하기 때문에 이를 통해 공격자는 직접적으로 이익을 얻을 수 있다. 

3.4 Reentrancy Vulnerability

Ethereum 계약에서 다른 호출을 하면 현재 실행이 완료될 때까지 기다린다. 
이때 호출 받는 사람이 호출자가 있는 중간 상태에 접근할 때 문제가 될 수 있다. 
계약할 때 이 사실이 알려지지 않을 수 있으므로 수신자 측이 악의적인 동작을 모를 수 있다. 
